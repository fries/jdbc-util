/*
 * Copyright (c) 2009-2025 the JdbcUtil authors
 *
 * SPDX-License-Identifier: MIT
 */

package de.schaeuffelhut.jdbc;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.util.Arrays;
import java.util.Iterator;

import static de.schaeuffelhut.jdbc.Utils.asIterable;

class PreparedStatementUtil
{
    private static final Logger LOGGER = LoggerFactory.getLogger( PreparedStatementUtil.class );

    public static PreparedStatement prepareStatement(Connection connection, String sql, Iterable<StatementInParameter> parameters) throws SQLException
    {
        return prepareStatement( connection, sql, null, parameters );
    }

    public static PreparedStatement prepareStatement(Connection connection, String sql, GeneratedKeys generatedKeys, Iterable<StatementInParameter> parameters) throws SQLException
    {
        sql = modifySql( sql, parameters );

        PreparedStatement stmt;
        if (generatedKeys == null)
            stmt = connection.prepareStatement( sql );
        else
            stmt = connection.prepareStatement( sql, generatedKeys.autoGeneratedKey );

        configureStatement( stmt, parameters );
        return stmt;
    }

    public final static String modifySql(String sql, Iterable<? extends StatementParameter> parameters)
    {
        final String unmodifiedSQL = sql;

        if (parameters != null)
            for (StatementParameter param : parameters)
                sql = param.modify( sql );

        if (unmodifiedSQL != sql && LOGGER.isTraceEnabled())
            LOGGER.trace( "modified sql: {}", sql );

        return sql;
    }

    public static void configureStatement(PreparedStatement stmt, Iterable<StatementInParameter> parameters) throws SQLException
    {
        int index = 1;
        if (parameters != null)
            for (StatementInParameter param : parameters)
                index += param.configure( stmt, index );
    }

    public static int execute(Connection connection, String sql, Iterable<StatementInParameter> parameters) throws SQLException
    {
        if (LOGGER.isTraceEnabled())
            LOGGER.trace( "execute: {}", sql );

        try (PreparedStatement stmt = prepareStatement( connection, sql, parameters ))
        {
            int count = stmt.executeUpdate();
            if (LOGGER.isTraceEnabled())
                LOGGER.trace( String.format( "updated %d records", count ) );
            return count;
        }
    }

    public static <T> T execute(Connection connection, GeneratedKeys generatedKeys, StatementProperty<T> statementProperty, String sql, Iterable<StatementInParameter> parameters) throws SQLException
    {
        if (LOGGER.isTraceEnabled())
            LOGGER.trace( "execute: {}", sql );

        try (PreparedStatement stmt = prepareStatement( connection, sql, generatedKeys, parameters ))
        {
            stmt.execute();

            if (statementProperty == null)
                return null;

            return statementProperty.get( stmt );
        }
    }

    public static Object[] execute(Connection connection, GeneratedKeys generatedKeys, StatementProperty<?>[] properties, String sql, Iterable<StatementInParameter> parameters) throws SQLException
    {
        if (LOGGER.isTraceEnabled())
            LOGGER.trace( "execute: {}", sql );

        try (PreparedStatement stmt = prepareStatement( connection, sql, generatedKeys, parameters ))
        {
            stmt.execute();

            final Object[] returnValues;
            if (properties != null)
            {
                returnValues = new Object[properties.length];
                for (int i = 0; i < properties.length; i++)
                    returnValues[i] = properties[i].get( stmt );
            }
            else
            {
                returnValues = null;
            }

            return returnValues;
        }
    }

    public static int[] executeBatch(Connection connection, String sql, Iterable<StatementInParameter[]> parameters) throws SQLException
    {
        if (LOGGER.isTraceEnabled())
            LOGGER.trace( "execute: {}", sql );

        try (PreparedStatement stmt = prepareBatchStatement( connection, sql, null, parameters ))
        {
            final int[] count;
            if (stmt == null) // happens if parameters == null
            {
                count = new int[0];
            }
            else
            {
                count = stmt.executeBatch();
                if (LOGGER.isTraceEnabled())
                    LOGGER.trace( "updated {} records", Arrays.asList( count ) );
            }
            return count;
        }
    }

    public static <T> T executeBatch(Connection connection, GeneratedKeys generatedKeys, StatementProperty<T> statementProperty, String sql, Iterable<StatementInParameter[]> batchParameters) throws SQLException
    {
        if (LOGGER.isTraceEnabled())
            LOGGER.trace( "execute: {}", sql );

        try (PreparedStatement stmt = prepareBatchStatement( connection, sql, generatedKeys, batchParameters ))
        {
            stmt.executeBatch();

            final T returnValue;
            if (statementProperty == null)
                returnValue = null;
            else
                returnValue = statementProperty.get( stmt );
            return returnValue;
        }
    }

    public static PreparedStatement prepareBatchStatement(Connection connection, String sql, GeneratedKeys generatedKeys, Iterable<StatementInParameter[]> batchParameters) throws SQLException
    {
        if (batchParameters == null)
            return null;

        Iterator<StatementInParameter[]> firstParameterSet = batchParameters.iterator();
        if (!firstParameterSet.hasNext())
            return null;

        sql = modifySql( sql, asIterable( firstParameterSet.next() ) );

        PreparedStatement stmt;
        if (generatedKeys == null)
            stmt = connection.prepareStatement( sql );
        else
            stmt = connection.prepareStatement( sql, generatedKeys.autoGeneratedKey );

        int i = 0;
        for (StatementInParameter[] parameters : batchParameters)
        {
            configureStatement( stmt, asIterable( parameters ) );
            if (LOGGER.isTraceEnabled())
                LOGGER.trace( "add batch {}", i );
            stmt.addBatch();
            i++;
        }

        return stmt;
    }

    // untested
    public static Object[] executeCall(Connection connection, String sql, StatementParameter... parameters) throws SQLException
    {
        return new Call().execute( connection, sql, parameters );
    }

    // Untested
    final static class Call
    {
        private CallableStatement stmt;
        private StatementParameter[] parameters;
        private int[] parameterIndices;

        public static void closeQuietly(Statement statement)
        {
            try
            {
                if (statement != null)
                    statement.close();
            }
            catch (SQLException e)
            {
                // ignore
            }
        }

        void prepare(Connection connection, String sql, StatementParameter... parameters) throws SQLException
        {
            if (stmt != null)
                throw new RuntimeException( "Statement is already prepared" );

            sql = modifySql( sql, asIterable( parameters ) );

            this.stmt = connection.prepareCall( sql );
            this.parameterIndices = new int[parameters.length];
            this.parameters = new StatementParameter[parameters.length];

            if (parameters != null)
            {
                int i = 0;
                int index = 1;
                for (StatementParameter param : parameters)
                {
                    this.parameterIndices[i] = index;
                    this.parameters[i] = parameters[i];

                    if (param instanceof StatementInParameter)
                        index += ((StatementInParameter) param).configure( stmt, index );
                    else if (param instanceof StatementOutParameter)
                        index += ((StatementOutParameter<?>) param).configure( stmt, index );
                    else if (param instanceof StatementProperty)
                        ;//ignore
                    else if (param == null)
                        ;// ignore
                    else
                        throw new RuntimeException( String.format(
                                "unkown implementation of interface %s: %s",
                                StatementParameter.class,
                                param.getClass()
                        ) );
                    i++;
                }
            }

        }

        Object[] read() throws SQLException
        {
            int countOutParams = 0;
            for (StatementParameter p : parameters)
            {
                if (p instanceof StatementOutParameter)
                    countOutParams++;
                else if (p instanceof StatementProperty)
                    countOutParams++;
                else
                    ; // ignore
            }

            Object[] returnValues = new Object[countOutParams];

            for (int i = 0, j = 0; i < parameters.length; i++)
            {
                if (parameters[i] instanceof StatementOutParameter<?> p)
                {
                    returnValues[j++] = p.readValue( stmt, parameterIndices[i] );
                }
                else if (parameters[i] instanceof StatementProperty<?> p)
                {
                    returnValues[j++] = p.get( stmt );
                }
                else
                {
                    // ignore
                }
            }

            return returnValues;
        }

        void close()
        {
            closeQuietly( stmt );
            stmt = null;
            parameterIndices = null;
            parameters = null;
        }

        Object[] execute(Connection connection) throws SQLException
        {
            if (stmt == null)
                throw new RuntimeException( "Statement is not prepared" );

            try
            {
                stmt.execute();
                return read();
            }
            finally
            {
                close();
            }
        }

        Object[] execute(Connection connection, String sql, StatementParameter... parameters) throws SQLException
        {
            prepare( connection, sql, parameters );
            return execute( connection );
        }

    }
}
